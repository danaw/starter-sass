var CssSyntaxError = require('postcss/lib/css-syntax-error');
var autoprefixer   = require('autoprefixer-core');
var path           = require('path');
var fs             = require('fs-extra');

var Binary = (function(){"use strict";var PRS$0 = (function(o,t){o["__proto__"]={"a":t};return o["a"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var proto$0={};var S_ITER$0 = typeof Symbol!=='undefined'&&Symbol&&Symbol.iterator||'@@iterator';var S_MARK$0 = typeof Symbol!=='undefined'&&Symbol&&Symbol["__setObjectSetter__"];function GET_ITER$0(v){if(v){if(Array.isArray(v))return 0;var f;if(S_MARK$0)S_MARK$0(v);if(typeof v==='object'&&typeof (f=v[S_ITER$0])==='function'){if(S_MARK$0)S_MARK$0(void 0);return f.call(v);}if(S_MARK$0)S_MARK$0(void 0);if((v+'')==='[object Generator]')return v;}throw new Error(v+' is not iterable')};
    function Binary(process) {
        this.arguments = process.argv.slice(2);
        this.stdin     = process.stdin;
        this.stderr    = process.stderr;
        this.stdout    = process.stdout;

        this.status     = 0;
        this.command    = 'compile';
        this.inputFiles = [];

        this.processOptions   = { };
        this.processorOptions = { };
        this.parseArguments();
    }DP$0(Binary,"prototype",{"configurable":false,"enumerable":false,"writable":false});

    // Quick help message
    proto$0.help = function() {
        return (
("Usage: autoprefixer [OPTION...] FILES\
\n\
\nParse CSS files and add prefixed properties and values.\
\n\
\nOptions:\
\n  -b, --browsers BROWSERS  add prefixes for selected browsers\
\n  -o, --output FILE        set output file\
\n  -d, --dir DIR            set output dir\
\n  -m, --map                generate source map\
\n      --no-map             skip source map even if previous map exists\
\n  -I, --inline-map         inline map by data:uri to annotation comment\
\n      --annotation PATH    change map location relative from CSS file\
\n      --no-map-annotation  skip source map annotation comment is CSS\
\n      --sources-content    Include origin CSS into map\
\n      --no-cascade         do not create nice visual cascade of prefixes\
\n      --safe               try to fix CSS syntax errors\
\n  -i, --info               show selected browsers and properties\
\n  -h, --help               show help text\
\n  -v, --version            print program version"));
    };

    // Options description
    proto$0.desc = function() {
        return (
("Files:\
\n  If you didn't set input files, autoprefixer will read from stdin stream.\
\n\
\n  By default, prefixed CSS will rewrite original files.\
\n\
\n  You can specify output file or directory by '-o' argument.\
\n  For several input files you can specify only output directory by '-d'.\
\n\
\n  Output CSS will be written to stdout stream on '-o -' argument or stdin input.\
\n\
\nSource maps:\
\n  On '-m' argument Autoprefixer will generate source map for changes near\
\n  output CSS (for out/main.css it generates out/main.css.map).\
\n\
\n  If previous source map will be near input files (for example, in/main.css\
\n  and in/main.css.map) Autoprefixer will apply previous map to output\
\n  source map.\
\n\
\nBrowsers:\
\n  Separate browsers by comma. For example, '-b \"> 1%, opera 12\"'.\
\n  You can set browsers by global usage statictics: '-b \"> 1%\"'.\
\n  or last version: '-b \"last 2 versions\"'."));
    };

    // Print to stdout
    proto$0.print = function(str) {
        str = str.replace(/\n$/, '');
        this.stdout.write(str + "\n");
    };

    // Print to stdout
    proto$0.error = function(str) {
        this.status = 1;
        this.stderr.write(str + "\n");
    };

    // Get current version
    proto$0.version = function() {
        return require('./package.json').version;
    };

    // Parse arguments
    proto$0.parseArguments = function() {
        var args = this.arguments.slice();
        while ( args.length > 0 ) {
            var arg = args.shift();

            if ( arg == '-h' || arg == '--help' ) {
                this.command = 'showHelp';

            } else if ( arg == '-v' || arg == '--version' ) {
                this.command = 'showVersion';

            } else if ( arg == '-i' || arg == '--info' ) {
                this.command = 'info';

            } else if ( arg == '-m' || arg == '--map' ) {
                this.processOptions.map = { };

            } else if ( arg == '--no-map' ) {
                this.processOptions.map = false;

            } else if ( arg == '-I' || arg == '--inline-map' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.inline = true;

            } else if ( arg == '--annotation' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.annotation = args.shift();

            } else if ( arg == '--no-map-annotation' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.annotation = false;

            } else if ( arg == '--sources-content' ) {
                if ( typeof( this.processOptions.map ) == 'undefined' ) {
                    this.processOptions.map = { };
                }
                this.processOptions.map.sourcesContent = true;

            } else if ( arg == '--no-cascade' ) {
                this.processorOptions.cascade = false;

            } else if ( arg == '--safe' ) {
                this.processOptions.safe = true;

            } else if ( arg == '-b' || arg == '--browsers' ) {
                this.processorOptions.browsers = args.shift().split(',')
                  .map( function(i)  {return i.trim()} );

            } else if ( arg == '-o' || arg == '--output' ) {
                this.outputFile = args.shift();

            } else if ( arg == '-d' || arg == '--dir' ) {
                this.outputDir = args.shift();

            } else {
                if ( arg.match(/^-\w$/) || arg.match(/^--\w[\w-]+$/) ) {
                    this.command = undefined;

                    this.error('autoprefixer: Unknown argument ' + arg);
                    this.error('');
                    this.error(this.help());

                } else {
                    this.inputFiles.push(arg);
                }
            }
        }
    };

    // Print help
    proto$0.showHelp = function(done) {
        this.print(this.help());
        this.print('');
        this.print(this.desc());
        done();
    };

    // Print version
    proto$0.showVersion = function(done) {
        this.print('autoprefixer ' + this.version());
        done();
    };

    // Print inspect
    proto$0.info = function(done) {
        this.print(this.compiler().info());
        done();
    };

    // Mark that there is another async work
    proto$0.startWork = function() {
        this.waiting += 1;
    };

    // Execute done callback if there is no works
    proto$0.endWork = function() {
        this.waiting -= 1;
        if ( this.waiting <= 0 ) this.doneCallback();
    };

    // Write error to stderr and finish work
    proto$0.workError = function(str) {
        this.error(str);
        this.endWork();
    };

    // Lazy loading for Autoprefixer instance
    proto$0.compiler = function() {
        if ( !this.compilerCache ) {
          this.compilerCache = autoprefixer(this.processorOptions);
        }
        return this.compilerCache;
    };

    // Compile loaded CSS
    proto$0.compileCSS = function(css, output, input) {var this$0 = this;
        var opts = { };
        for ( var name in this.processOptions ) {
            opts[name] = this.processOptions[name];
        }
        if ( input )         opts.from = input;
        if ( output != '-' ) opts.to   = output;

        var result;
        try {
            result = this.compiler().process(css, opts);
        } catch (error) {
            if ( error.autoprefixer ) {
                this.error('autoprefixer: ' + error.message);
            } else if ( error instanceof CssSyntaxError ) {
                this.error('autoprefixer:' + error.toString());
            } else {
                this.error('autoprefixer: Internal error');
                if ( error.stack ) {
                    this.error('');
                    this.error(error.stack);
                }
            }
        }

        if ( !result ) return this.endWork();

        if ( output == '-' ) {
            this.print(result.css);
            this.endWork();
        } else {
            fs.outputFile(output, result.css, function(error)  {
                if (error) this$0.error('autoprefixer: ' + error);

                if ( result.map ) {
                  var map;
                  if ( opts.map && opts.map.annotation ) {
                      map = path.resolve(path.dirname(output),
                                         opts.map.annotation);
                  } else {
                      map = output + '.map';
                  }
                  fs.writeFile(map, result.map, function(error)  {
                      if (error) this$0.error('autoprefixer: ' + error);
                      this$0.endWork();
                  });
                } else {
                    this$0.endWork();
                }
            });
        }
    };

    // Return input and output files array
    proto$0.files = function() {var $D$0;var $D$1;var $D$2;var $D$3;
        if ( this.inputFiles.length === 0 && !this.outputFile ) {
            this.outputFile = '-';
        }

        var file, list = [];
        if ( this.outputDir ) {
            if ( this.inputFiles.length === 0 ) {
                this.error('autoprefixer: For STDIN input you need ' +
                           'to specify output file (by -o FILE),\n ' +
                           'not output dir');
                return;
            }

            var dir = this.outputDir;
            if ( fs.existsSync(dir) && !fs.statSync(dir).isDirectory() ) {
                this.error('autoprefixer: Path ' + dir +
                           ' is a file, not directory');
                return;
            }

            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ;$D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"];){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                var output = path.join(this.outputDir, path.basename(file));
                list.push([file, output]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;

        } else if ( this.outputFile ) {
            if ( this.inputFiles.length > 1 ) {
                this.error('autoprefixer: For several files you can ' +
                           'specify only output dir (by -d DIR`),\n' +
                           'not one output file');
                return;
            }

            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ;$D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"];){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                list.push([file, this.outputFile]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;

        } else {
            $D$3 = (this.inputFiles);$D$0 = GET_ITER$0($D$3);$D$2 = $D$0 === 0;$D$1 = ($D$2 ? $D$3.length : void 0);for ( file ;$D$2 ? ($D$0 < $D$1) : !($D$1 = $D$0["next"]())["done"];){file = ($D$2 ? $D$3[$D$0++] : $D$1["value"]);
                list.push([file, file]);
            };$D$0 = $D$1 = $D$2 = $D$3 = void 0;
        }

        return list;
    };

    // Compile selected files
    proto$0.compile = function(done) {var $D$4;var $D$5;var $D$6;var this$0 = this;
        this.waiting      = 0;
        this.doneCallback = done;

        var files = this.files();
        if ( !files ) return done();

        if ( files.length === 0 ) {
            this.startWork();

            var css = '';
            this.stdin.resume();
            this.stdin.on('data', function(chunk)  {return css += chunk});
            this.stdin.on('end', function()  {
                this$0.compileCSS(css, this$0.outputFile);
            });
        } else {
            var file, input, output;
            $D$4 = GET_ITER$0(files);$D$6 = $D$4 === 0;$D$5 = ($D$6 ? files.length : void 0);for ( file ;$D$6 ? ($D$4 < $D$5) : !($D$5 = $D$4["next"]())["done"];){file = ($D$6 ? files[$D$4++] : $D$5["value"]);
                this.startWork();
            };$D$4 = $D$5 = $D$6 = void 0;
            $D$4 = GET_ITER$0(files);$D$6 = $D$4 === 0;$D$5 = ($D$6 ? files.length : void 0);for ( file ;$D$6 ? ($D$4 < $D$5) : !($D$5 = $D$4["next"]())["done"];){file = ($D$6 ? files[$D$4++] : $D$5["value"]);
                input = file[0], output = file[1], file;

                if ( !fs.existsSync(input) ) {
                    this.workError('autoprefixer: File ' + input +
                                   'doesn\'t exists');
                    continue;
                }

                (function(input, output)  {
                    fs.readFile(input, function(error, css)  {
                        if ( error ) {
                            this$0.workError('autoprefixer: ' + error.message);
                        } else {
                            this$0.compileCSS(css, output, input);
                        }
                    });
                })(input, output);
            };$D$4 = $D$5 = $D$6 = void 0;
        }
    };

    // Execute command selected by arguments
    proto$0.run = function(done) {
        if ( this.command ) {
            this[this.command](done);
        } else {
            done();
        }
    };
MIXIN$0(Binary.prototype,proto$0);proto$0=void 0;return Binary;})();

module.exports = Binary;
